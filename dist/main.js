/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/1_Fundamentals/01_fundamentals.ts":
/*!***********************************************!*\
  !*** ./src/1_Fundamentals/01_fundamentals.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertex_shader_2d = `\r\nattribute vec4 a_position;\r\nvoid main(){\r\n    gl_Position = a_position;\r\n}`;\r\nconst fragment_shader_2d = `\r\nprecision mediump float;\r\nvoid main(){\r\n    gl_FragColor = vec4(1,0,0.5,1);\r\n}`;\r\nfunction createShader(gl, type, source) {\r\n    let shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) {\r\n        return shader;\r\n    }\r\n    console.log(gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n}\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n    let program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (success) {\r\n        return program;\r\n    }\r\n    console.log(gl.getProgramInfoLog(program));\r\n    gl.deleteProgram(program);\r\n}\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    let gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    // 获取着色器字符串\r\n    let vertexShaderSource = vertex_shader_2d;\r\n    let fragmentShaderSource = fragment_shader_2d;\r\n    let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n    let program = createProgram(gl, vertexShader, fragmentShader);\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    const positions = [\r\n        0, 0,\r\n        0, 0.5,\r\n        0.7, 0\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    // 清空画布\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    // 告诉它用我们之前写好的着色程序（一个着色器对）\r\n    gl.useProgram(program);\r\n    // 启用对应属性\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    // 将绑定点绑定到缓冲数据（positionBuffer）\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    // 告诉属性怎么从positionBuffer中读取数据 (ARRAY_BUFFER)\r\n    var size = 2; // 每次迭代运行提取两个单位数据\r\n    var type = gl.FLOAT; // 每个单位的数据类型是32位浮点型\r\n    var normalize = false; // 不需要归一化数据\r\n    var stride = 0; // 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）每次迭代运行运动多少内存到下一个数据开始点\r\n    var offset = 0; // 从缓冲起始位置开始读取\r\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n    // 绘制\r\n    var primitiveType = gl.TRIANGLES;\r\n    var offset = 0;\r\n    var count = 3;\r\n    gl.drawArrays(primitiveType, offset, count);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1_Fundamentals/01_fundamentals.ts?");

/***/ }),

/***/ "./src/1_Fundamentals/02_2d_rectangle.ts":
/*!***********************************************!*\
  !*** ./src/1_Fundamentals/02_2d_rectangle.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertex_shader_2d = `\r\nattribute vec4 a_position;\r\n\r\nuniform vec2 u_resolution;\r\n\r\nvoid main(){\r\n    // 从像素坐标转换到 0.0 到 1.0\r\n    vec2 zeroToOne = a_position.xy/u_resolution;\r\n    // 再把 0->1 转换 0->2\r\n    vec2 zeroToTwo = zeroToOne * 2.0;\r\n    // 把 0->2 转换到 -1->+1 (裁剪空间)\r\n    vec2 clipSpace = zeroToTwo - 1.0;\r\n    gl_Position = vec4(clipSpace, 0, 1);\r\n}`;\r\nconst fragment_shader_2d = `\r\nprecision mediump float;\r\nvoid main(){\r\n    gl_FragColor = vec4(1,0,0.5,1);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    let gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    // 获取着色器字符串\r\n    let vertexShaderSource = vertex_shader_2d;\r\n    let fragmentShaderSource = fragment_shader_2d;\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    const positions = [\r\n        10, 20,\r\n        80, 20,\r\n        10, 30,\r\n        10, 30,\r\n        80, 20,\r\n        80, 30,\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    // 清空画布\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    // 告诉它用我们之前写好的着色程序（一个着色器对）\r\n    gl.useProgram(program);\r\n    // 启用对应属性\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    // 将绑定点绑定到缓冲数据（positionBuffer）\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    // 告诉属性怎么从positionBuffer中读取数据 (ARRAY_BUFFER)\r\n    var size = 2; // 每次迭代运行提取两个单位数据\r\n    var type = gl.FLOAT; // 每个单位的数据类型是32位浮点型\r\n    var normalize = false; // 不需要归一化数据\r\n    var stride = 0; // 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）每次迭代运行运动多少内存到下一个数据开始点\r\n    var offset = 0; // 从缓冲起始位置开始读取\r\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n    // 绘制\r\n    var primitiveType = gl.TRIANGLES;\r\n    var offset = 0;\r\n    var count = 6;\r\n    gl.drawArrays(primitiveType, offset, count);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1_Fundamentals/02_2d_rectangle.ts?");

/***/ }),

/***/ "./src/1_Fundamentals/03_2d_rectangle_top_left.ts":
/*!********************************************************!*\
  !*** ./src/1_Fundamentals/03_2d_rectangle_top_left.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertex_shader_2d = `\r\nattribute vec4 a_position;\r\n\r\nuniform vec2 u_resolution;\r\n\r\nvoid main(){\r\n    vec2 zeroToOne = a_position.xy / u_resolution;\r\n    vec2 zeroToTwo = zeroToOne*2.0;\r\n    vec2 clipSpace = zeroToTwo - 1.0;\r\n    // 翻转y轴, 使起点在左上角\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n}`;\r\nconst fragment_shader_2d = `\r\nprecision mediump float;\r\n\r\nvoid main(){\r\n    gl_FragColor = vec4(1.0, 0, 0.5, 1);\r\n}`;\r\nfunction main() {\r\n    let canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertex_shader_2d, fragment_shader_2d]);\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');\r\n    let positionbuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionbuffer);\r\n    var positions = [\r\n        10, 20,\r\n        80, 20,\r\n        10, 30,\r\n        10, 30,\r\n        80, 20,\r\n        80, 30,\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionbuffer);\r\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1_Fundamentals/03_2d_rectangle_top_left.ts?");

/***/ }),

/***/ "./src/1_Fundamentals/04_2d_rectangles.ts":
/*!************************************************!*\
  !*** ./src/1_Fundamentals/04_2d_rectangles.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertex_shader_2d = `\r\nattribute vec2 a_position;\r\nuniform vec2 u_resolution;\r\n\r\nvoid main(){\r\n    vec2 zeroToOne=a_position/u_resolution;\r\n    vec2 zeroToTwo = zeroToOne*2.0;\r\n    vec2 clipSpace = zeroToTwo -1.0;\r\n\r\n    gl_Position = vec4(clipSpace * vec2(1,-1), 0, 1);\r\n}`;\r\nconst fragment_shader_2d = `\r\nprecision mediump float;\r\n\r\nuniform vec4 u_color;\r\nvoid main(){\r\n    gl_FragColor = u_color;\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertex_shader_2d, fragment_shader_2d]);\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');\r\n    let colorUniformLocation = gl.getUniformLocation(program, 'u_color');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n    for (var ii = 0; ii < 50; ii++) {\r\n        setRectangle(gl, randomInt(300), randomInt(300), randomInt(400), randomInt(400));\r\n        gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n}\r\nfunction randomInt(range) {\r\n    return Math.floor(Math.random() * range);\r\n}\r\nfunction setRectangle(gl, x, y, width, height) {\r\n    var x1 = x;\r\n    var x2 = x + width;\r\n    var y1 = y;\r\n    var y2 = y + height;\r\n    /*x1y2 x1y2----x2y2\r\n        | \\          |\r\n        |    \\       |\r\n      x1y1----x2y1 x2y1*/\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        x1, y1,\r\n        x2, y1,\r\n        x1, y2,\r\n        x1, y2,\r\n        x2, y1,\r\n        x2, y2,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1_Fundamentals/04_2d_rectangles.ts?");

/***/ }),

/***/ "./src/8_Textures/01_3d_textures.ts":
/*!******************************************!*\
  !*** ./src/8_Textures/01_3d_textures.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\nconst vertex_shader_3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragment_shader_3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor= texture2D(u_texture,v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext(\"webgl\");\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createProgramFromStrings(gl, [vertex_shader_3d, fragment_shader_3d]);\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let texcoordAttributeLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    let matrixUniformLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    let textureUniformLocation = gl.getUniformLocation(program, 'u_texture');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    setTexcoord(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = \"./resources/images/f-texture.png\";\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    });\r\n    // 弧度变角度\r\n    let radToDeg = (r) => {\r\n        return r * 180 / Math.PI;\r\n    };\r\n    //角度变弧度\r\n    let degToRad = (d) => {\r\n        return d * Math.PI / 180;\r\n    };\r\n    let fieldOfViewRadians = degToRad(60);\r\n    let modelXRotationRadians = degToRad(0);\r\n    let modelYRotationRadians = degToRad(0);\r\n    let then = 0;\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(now) {\r\n        now *= 0.001;\r\n        let deltaTime = now - then;\r\n        then = now;\r\n        if (!gl) {\r\n            return;\r\n        }\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        modelXRotationRadians += 1.2 * deltaTime;\r\n        modelYRotationRadians += 0.7 * deltaTime;\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordAttributeLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n        gl.vertexAttribPointer(texcoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, 1, 2000);\r\n        let cameraPosition = [0, 0, 200];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].xRotate(viewProjectionMatrix, modelXRotationRadians);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].yRotate(matrix, modelXRotationRadians);\r\n        gl.uniformMatrix4fv(matrixUniformLocation, false, matrix);\r\n        gl.uniform1i(textureUniformLocation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 16 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        // left column front\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        // top rung front\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        // middle rung front\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        // left column back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // top rung back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // middle rung back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // top\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // top rung right\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // under top rung\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // between top rung and middle\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // top of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // right of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom of middle rung.\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // right of bottom\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // left side\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0\r\n    ]), gl.STATIC_DRAW);\r\n}\r\nfunction setGeometry(gl) {\r\n    var positions = new Float32Array([\r\n        // left column front\r\n        0, 0, 0,\r\n        0, 150, 0,\r\n        30, 0, 0,\r\n        0, 150, 0,\r\n        30, 150, 0,\r\n        30, 0, 0,\r\n        // top rung front\r\n        30, 0, 0,\r\n        30, 30, 0,\r\n        100, 0, 0,\r\n        30, 30, 0,\r\n        100, 30, 0,\r\n        100, 0, 0,\r\n        // middle rung front\r\n        30, 60, 0,\r\n        30, 90, 0,\r\n        67, 60, 0,\r\n        30, 90, 0,\r\n        67, 90, 0,\r\n        67, 60, 0,\r\n        // left column back\r\n        0, 0, 30,\r\n        30, 0, 30,\r\n        0, 150, 30,\r\n        0, 150, 30,\r\n        30, 0, 30,\r\n        30, 150, 30,\r\n        // top rung back\r\n        30, 0, 30,\r\n        100, 0, 30,\r\n        30, 30, 30,\r\n        30, 30, 30,\r\n        100, 0, 30,\r\n        100, 30, 30,\r\n        // middle rung back\r\n        30, 60, 30,\r\n        67, 60, 30,\r\n        30, 90, 30,\r\n        30, 90, 30,\r\n        67, 60, 30,\r\n        67, 90, 30,\r\n        // top\r\n        0, 0, 0,\r\n        100, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 30,\r\n        // top rung right\r\n        100, 0, 0,\r\n        100, 30, 0,\r\n        100, 30, 30,\r\n        100, 0, 0,\r\n        100, 30, 30,\r\n        100, 0, 30,\r\n        // under top rung\r\n        30, 30, 0,\r\n        30, 30, 30,\r\n        100, 30, 30,\r\n        30, 30, 0,\r\n        100, 30, 30,\r\n        100, 30, 0,\r\n        // between top rung and middle\r\n        30, 30, 0,\r\n        30, 60, 30,\r\n        30, 30, 30,\r\n        30, 30, 0,\r\n        30, 60, 0,\r\n        30, 60, 30,\r\n        // top of middle rung\r\n        30, 60, 0,\r\n        67, 60, 30,\r\n        30, 60, 30,\r\n        30, 60, 0,\r\n        67, 60, 0,\r\n        67, 60, 30,\r\n        // right of middle rung\r\n        67, 60, 0,\r\n        67, 90, 30,\r\n        67, 60, 30,\r\n        67, 60, 0,\r\n        67, 90, 0,\r\n        67, 90, 30,\r\n        // bottom of middle rung.\r\n        30, 90, 0,\r\n        30, 90, 30,\r\n        67, 90, 30,\r\n        30, 90, 0,\r\n        67, 90, 30,\r\n        67, 90, 0,\r\n        // right of bottom\r\n        30, 90, 0,\r\n        30, 150, 30,\r\n        30, 90, 30,\r\n        30, 90, 0,\r\n        30, 150, 0,\r\n        30, 150, 30,\r\n        // bottom\r\n        0, 150, 0,\r\n        0, 150, 30,\r\n        30, 150, 30,\r\n        0, 150, 0,\r\n        30, 150, 30,\r\n        30, 150, 0,\r\n        // left side\r\n        0, 0, 0,\r\n        0, 0, 30,\r\n        0, 150, 30,\r\n        0, 0, 0,\r\n        0, 150, 30,\r\n        0, 150, 0\r\n    ]);\r\n    let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity();\r\n    matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(matrix, -50, -75, -15);\r\n    for (let ii = 0; ii < positions.length; ii += 3) {\r\n        let vector = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].transformVector(matrix, [positions[ii], positions[ii + 1], positions[ii + 2], 1]);\r\n        positions[ii] = vector[0];\r\n        positions[ii + 1] = vector[1];\r\n        positions[ii + 2] = vector[2];\r\n    }\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/01_3d_textures.ts?");

/***/ }),

/***/ "./src/8_Textures/02_3d_textures_texture_coords_mapped.ts":
/*!****************************************************************!*\
  !*** ./src/8_Textures/02_3d_textures_texture_coords_mapped.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture,v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    let positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    let texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    let matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    let textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    setTexcoords(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/f-texture.png';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    });\r\n    let degToRad = (d) => {\r\n        return d * Math.PI / 180;\r\n    };\r\n    let fieldOfViewRadians = degToRad(60);\r\n    let modelXRotationRadians = degToRad(0);\r\n    let modelYRotationRadians = degToRad(0);\r\n    let then = 0;\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(now) {\r\n        now *= 0.001;\r\n        let deltaTime = now - then;\r\n        then = now;\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        modelXRotationRadians += 1.2 * deltaTime;\r\n        modelYRotationRadians += 0.7 * deltaTime;\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, 1, 2000);\r\n        let cameraPosition = [0, 0, 200];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].xRotate(viewProjectionMatrix, modelXRotationRadians);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].yRotate(matrix, modelYRotationRadians);\r\n        gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n        gl.uniform1i(textureLocation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 16 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setTexcoords(gl) {\r\n    let texcoord = new Float32Array([\r\n        // left column front\r\n        38 / 255, 44 / 255,\r\n        38 / 255, 223 / 255,\r\n        113 / 255, 44 / 255,\r\n        38 / 255, 223 / 255,\r\n        113 / 255, 223 / 255,\r\n        113 / 255, 44 / 255,\r\n        // top rung front\r\n        113 / 255, 44 / 255,\r\n        113 / 255, 85 / 255,\r\n        218 / 255, 44 / 255,\r\n        113 / 255, 85 / 255,\r\n        218 / 255, 85 / 255,\r\n        218 / 255, 44 / 255,\r\n        // middle rung front\r\n        113 / 255, 112 / 255,\r\n        113 / 255, 151 / 255,\r\n        203 / 255, 112 / 255,\r\n        113 / 255, 151 / 255,\r\n        203 / 255, 151 / 255,\r\n        203 / 255, 112 / 255,\r\n        // left column back\r\n        38 / 255, 44 / 255,\r\n        113 / 255, 44 / 255,\r\n        38 / 255, 223 / 255,\r\n        38 / 255, 223 / 255,\r\n        113 / 255, 44 / 255,\r\n        113 / 255, 223 / 255,\r\n        // top rung back\r\n        113 / 255, 44 / 255,\r\n        218 / 255, 44 / 255,\r\n        113 / 255, 85 / 255,\r\n        113 / 255, 85 / 255,\r\n        218 / 255, 44 / 255,\r\n        218 / 255, 85 / 255,\r\n        // middle rung back\r\n        113 / 255, 112 / 255,\r\n        203 / 255, 112 / 255,\r\n        113 / 255, 151 / 255,\r\n        113 / 255, 151 / 255,\r\n        203 / 255, 112 / 255,\r\n        203 / 255, 151 / 255,\r\n        // top\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // top rung right\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // under top rung\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // between top rung and middle\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // top of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // right of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom of middle rung.\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // right of bottom\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // left side\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n    ]);\r\n    gl.bufferData(gl.ARRAY_BUFFER, texcoord, gl.STATIC_DRAW);\r\n}\r\nfunction setGeometry(gl) {\r\n    var positions = new Float32Array([\r\n        // left column front\r\n        0, 0, 0,\r\n        0, 150, 0,\r\n        30, 0, 0,\r\n        0, 150, 0,\r\n        30, 150, 0,\r\n        30, 0, 0,\r\n        // top rung front\r\n        30, 0, 0,\r\n        30, 30, 0,\r\n        100, 0, 0,\r\n        30, 30, 0,\r\n        100, 30, 0,\r\n        100, 0, 0,\r\n        // middle rung front\r\n        30, 60, 0,\r\n        30, 90, 0,\r\n        67, 60, 0,\r\n        30, 90, 0,\r\n        67, 90, 0,\r\n        67, 60, 0,\r\n        // left column back\r\n        0, 0, 30,\r\n        30, 0, 30,\r\n        0, 150, 30,\r\n        0, 150, 30,\r\n        30, 0, 30,\r\n        30, 150, 30,\r\n        // top rung back\r\n        30, 0, 30,\r\n        100, 0, 30,\r\n        30, 30, 30,\r\n        30, 30, 30,\r\n        100, 0, 30,\r\n        100, 30, 30,\r\n        // middle rung back\r\n        30, 60, 30,\r\n        67, 60, 30,\r\n        30, 90, 30,\r\n        30, 90, 30,\r\n        67, 60, 30,\r\n        67, 90, 30,\r\n        // top\r\n        0, 0, 0,\r\n        100, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 30,\r\n        // top rung right\r\n        100, 0, 0,\r\n        100, 30, 0,\r\n        100, 30, 30,\r\n        100, 0, 0,\r\n        100, 30, 30,\r\n        100, 0, 30,\r\n        // under top rung\r\n        30, 30, 0,\r\n        30, 30, 30,\r\n        100, 30, 30,\r\n        30, 30, 0,\r\n        100, 30, 30,\r\n        100, 30, 0,\r\n        // between top rung and middle\r\n        30, 30, 0,\r\n        30, 60, 30,\r\n        30, 30, 30,\r\n        30, 30, 0,\r\n        30, 60, 0,\r\n        30, 60, 30,\r\n        // top of middle rung\r\n        30, 60, 0,\r\n        67, 60, 30,\r\n        30, 60, 30,\r\n        30, 60, 0,\r\n        67, 60, 0,\r\n        67, 60, 30,\r\n        // right of middle rung\r\n        67, 60, 0,\r\n        67, 90, 30,\r\n        67, 60, 30,\r\n        67, 60, 0,\r\n        67, 90, 0,\r\n        67, 90, 30,\r\n        // bottom of middle rung.\r\n        30, 90, 0,\r\n        30, 90, 30,\r\n        67, 90, 30,\r\n        30, 90, 0,\r\n        67, 90, 30,\r\n        67, 90, 0,\r\n        // right of bottom\r\n        30, 90, 0,\r\n        30, 150, 30,\r\n        30, 90, 30,\r\n        30, 90, 0,\r\n        30, 150, 0,\r\n        30, 150, 30,\r\n        // bottom\r\n        0, 150, 0,\r\n        0, 150, 30,\r\n        30, 150, 30,\r\n        0, 150, 0,\r\n        30, 150, 30,\r\n        30, 150, 0,\r\n        // left side\r\n        0, 0, 0,\r\n        0, 0, 30,\r\n        0, 150, 30,\r\n        0, 0, 0,\r\n        0, 150, 30,\r\n        0, 150, 0\r\n    ]);\r\n    let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity();\r\n    matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(matrix, -50, -75, -15);\r\n    for (let ii = 0; ii < positions.length; ii += 3) {\r\n        let vector = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].transformVector(matrix, [positions[ii], positions[ii + 1], positions[ii + 2], 1]);\r\n        positions[ii] = vector[0];\r\n        positions[ii + 1] = vector[1];\r\n        positions[ii + 2] = vector[2];\r\n    }\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/02_3d_textures_texture_coords_mapped.ts?");

/***/ }),

/***/ "./src/8_Textures/03_3d_textures_repear_clamp.ts":
/*!*******************************************************!*\
  !*** ./src/8_Textures/03_3d_textures_repear_clamp.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture, v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    setTexcoords(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/f-texture.png';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n        drawScene();\r\n    });\r\n    let wrapS = gl.REPEAT;\r\n    let wrapT = gl.REPEAT;\r\n    document.querySelector('#wrap_s0').addEventListener('click', () => {\r\n        wrapS = gl.REPEAT;\r\n        drawScene();\r\n    });\r\n    document.querySelector('#wrap_s1').addEventListener('click', () => {\r\n        wrapS = gl.CLAMP_TO_EDGE;\r\n        drawScene();\r\n    });\r\n    document.querySelector('#wrap_s2').addEventListener('click', () => {\r\n        wrapS = gl.MIRRORED_REPEAT;\r\n        drawScene();\r\n    });\r\n    document.querySelector('#wrap_t0').addEventListener('click', () => {\r\n        wrapT = gl.REPEAT;\r\n        drawScene();\r\n    });\r\n    document.querySelector('#wrap_t1').addEventListener('click', () => {\r\n        wrapT = gl.CLAMP_TO_EDGE;\r\n        drawScene();\r\n    });\r\n    document.querySelector('#wrap_t2').addEventListener('click', () => {\r\n        wrapT = gl.MIRRORED_REPEAT;\r\n        drawScene();\r\n    });\r\n    let isPowerOf2 = (value) => {\r\n        return (value & (value - 1)) === 0;\r\n    };\r\n    let degToRad = (d) => {\r\n        return d * Math.PI / 180;\r\n    };\r\n    let gridContainer = document.getElementById('gridContainer');\r\n    let fieldOfViewInRadians = degToRad(60);\r\n    drawScene();\r\n    function drawScene() {\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        let scaleFactor = 2.5;\r\n        let tsize = 80 * scaleFactor;\r\n        let x = gl.canvas.clientWidth / 2 - tsize / 2;\r\n        let y = gl.canvas.clientHeight / 2 - tsize - 60;\r\n        gridContainer.style.left = (x - 50 * scaleFactor) + 'px';\r\n        gridContainer.style.top = (y - 50 * scaleFactor) + 'px';\r\n        gridContainer.style.width = (400 * scaleFactor) + 'px';\r\n        gridContainer.style.height = (300 * scaleFactor) + 'px';\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].orthographic(0, gl.canvas.clientWidth, gl.canvas.height, 0, -1, 1);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(projectionMatrix, x, y, 0);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale(matrix, tsize, tsize, 1);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(matrix, 0.5, 0.5, 0);\r\n        gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n        gl.uniform1i(textureLocation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 1 * 6);\r\n    }\r\n}\r\nfunction setGeometry(gl) {\r\n    let positions = new Float32Array([\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n    ]);\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\nfunction setTexcoords(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        -3, -1,\r\n        2, -1,\r\n        -3, 4,\r\n        -3, 4,\r\n        2, -1,\r\n        2, 4,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/03_3d_textures_repear_clamp.ts?");

/***/ }),

/***/ "./src/8_Textures/04-3d-textures-mips.ts":
/*!***********************************************!*\
  !*** ./src/8_Textures/04-3d-textures-mips.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentVertex3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture,v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentVertex3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    const texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    setTexcoord(gl);\r\n    let allocateFBTexture = true;\r\n    let framebufferWidth;\r\n    let framebufferheight;\r\n    let framebuffer = gl.createFramebuffer();\r\n    let fbTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, fbTexture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTexture, 0);\r\n    let textrue = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, textrue);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/mip-low-res-example.png';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, textrue);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n    });\r\n    let isPowerOf2 = (value) => {\r\n        return (value & (value - 1)) === 0;\r\n    };\r\n    let radToDeg = (r) => {\r\n        return r * 180 / Math.PI;\r\n    };\r\n    let degToRad = (d) => {\r\n        return d * Math.PI / 180;\r\n    };\r\n    let fieldOfViewRadians = degToRad(60);\r\n    let modelXRotationRadians = degToRad(0);\r\n    let modelYRotationRadians = degToRad(0);\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(time) {\r\n        time *= 0.001;\r\n        if (_resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resizeCanvasToDisplaySize(gl.canvas, window.devicePixelRatio) || allocateFBTexture) {\r\n            allocateFBTexture = false;\r\n            framebufferWidth = gl.canvas.clientWidth / 4;\r\n            framebufferheight = gl.canvas.clientHeight / 4;\r\n            gl.bindTexture(gl.TEXTURE_2D, fbTexture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, framebufferWidth, framebufferheight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        }\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.viewport(0, 0, framebufferWidth, framebufferheight);\r\n        gl.clearColor(0, 0, 0, 1);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let zNear = 1;\r\n        let zFar = 2000;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, zNear, zFar);\r\n        let cameraPosition = [0, 0, 3];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let settings = [\r\n            { x: -1, y: -3, z: -30, filter: gl.NEAREST, },\r\n            { x: 0, y: -3, z: -30, filter: gl.LINEAR, },\r\n            { x: 1, y: -3, z: -30, filter: gl.NEAREST_MIPMAP_LINEAR, },\r\n            { x: -1, y: -1, z: -10, filter: gl.NEAREST, },\r\n            { x: 0, y: -1, z: -10, filter: gl.LINEAR, },\r\n            { x: 1, y: -1, z: -10, filter: gl.NEAREST_MIPMAP_LINEAR, },\r\n            { x: -1, y: 1, z: 0, filter: gl.NEAREST, },\r\n            { x: 0, y: 1, z: 0, filter: gl.LINEAR, },\r\n            { x: 1, y: 1, z: 0, filter: gl.LINEAR_MIPMAP_NEAREST, },\r\n        ];\r\n        let xSpacing = 1.2;\r\n        let ySpacing = 0.7;\r\n        let zDistance = 30;\r\n        settings.forEach((s) => {\r\n            let z = -5 + s.z;\r\n            let r = Math.abs(z) * Math.sin(fieldOfViewRadians * 0.5);\r\n            let x = Math.sin(time * 0.2) * r;\r\n            let y = Math.cos(time * 0.2) * r * 0.5;\r\n            let r2 = 1 + r * 0.2;\r\n            gl.bindTexture(gl.TEXTURE_2D, textrue);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, s.filter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            let matrixX = x + s.x * xSpacing * r2;\r\n            let matrixY = y + s.y * ySpacing * r2;\r\n            let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(projectionMatrix, matrixX, matrixY, z);\r\n            gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n            gl.uniform1i(textureLocation, 0);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 1 * 6);\r\n        });\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.bindTexture(gl.TEXTURE_2D, fbTexture);\r\n        gl.uniformMatrix4fv(matrixLocation, false, [\r\n            2, 0, 0, 0,\r\n            0, 2, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 1 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setGeometry(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/04-3d-textures-mips.ts?");

/***/ }),

/***/ "./src/8_Textures/05_3d_textures_mips_tri_linear.ts":
/*!**********************************************************!*\
  !*** ./src/8_Textures/05_3d_textures_mips_tri_linear.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture, v_texcoord);\r\n}`;\r\nlet zDepth = 50;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBUffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n    setTexcoord(gl);\r\n    let mipTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, mipTexture);\r\n    let c = document.createElement('canvas');\r\n    let ctx = c.getContext('2d');\r\n    let mips = [\r\n        { size: 64, color: \"rgb(128,0,255)\", },\r\n        { size: 32, color: \"rgb(0,0,255)\", },\r\n        { size: 16, color: \"rgb(255,0,0)\", },\r\n        { size: 8, color: \"rgb(255,255,0)\", },\r\n        { size: 4, color: \"rgb(0,255,0)\", },\r\n        { size: 2, color: \"rgb(0,255,255)\", },\r\n        { size: 1, color: \"rgb(255,0,255)\", },\r\n    ];\r\n    mips.forEach((s, level) => {\r\n        let size = s.size;\r\n        c.width = size;\r\n        c.height = size;\r\n        ctx.fillStyle = 'rgb(255,255,255)';\r\n        ctx.fillRect(0, 0, size, size);\r\n        ctx.fillStyle = s.color;\r\n        ctx.fillRect(0, 0, size / 2, size / 2);\r\n        ctx.fillRect(size / 2, size / 2, size / 2, size / 2);\r\n        gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);\r\n    });\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/mip-low-res-example.png';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n        drawScene();\r\n    });\r\n    let textures = [texture, mipTexture];\r\n    let textureIndex = 0;\r\n    document.body.addEventListener('click', () => {\r\n        textureIndex = (textureIndex + 1) % textures.length;\r\n        drawScene();\r\n    });\r\n    let isPowerOf2 = (value) => {\r\n        return (value & (value - 1)) === 0;\r\n    };\r\n    let degToRad = (d) => {\r\n        return d * Math.PI / 180;\r\n    };\r\n    let fieldOfViewRadians = degToRad(60);\r\n    drawScene();\r\n    function drawScene() {\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.clearColor(0, 0, 0, 1);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let zNear = 1;\r\n        let zFar = 2000;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, zNear, zFar);\r\n        let cameraPosition = [0, 0, 2];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let settings = [\r\n            { x: -1, y: 1, zRot: 0, magFilter: gl.NEAREST, minFilter: gl.NEAREST, },\r\n            { x: 0, y: 1, zRot: 0, magFilter: gl.LINEAR, minFilter: gl.LINEAR, },\r\n            { x: 1, y: 1, zRot: 0, magFilter: gl.LINEAR, minFilter: gl.NEAREST_MIPMAP_NEAREST, },\r\n            { x: -1, y: -1, zRot: 1, magFilter: gl.LINEAR, minFilter: gl.LINEAR_MIPMAP_NEAREST, },\r\n            { x: 0, y: -1, zRot: 1, magFilter: gl.LINEAR, minFilter: gl.NEAREST_MIPMAP_LINEAR, },\r\n            { x: 1, y: -1, zRot: 1, magFilter: gl.LINEAR, minFilter: gl.LINEAR_MIPMAP_LINEAR, },\r\n        ];\r\n        let xSpacing = 1.2;\r\n        let ySpacing = 0.7;\r\n        settings.forEach((s) => {\r\n            gl.bindTexture(gl.TEXTURE_2D, textures[textureIndex]);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, s.minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, s.magFilter);\r\n            let matrixX = s.x * xSpacing;\r\n            let matrixY = s.y * ySpacing;\r\n            let matrixZ = -zDepth * 0.5;\r\n            let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(viewProjectionMatrix, matrixX, matrixY, matrixZ);\r\n            matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zRotate(matrix, s.zRot * Math.PI);\r\n            matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale(matrix, 1, 1, zDepth);\r\n            gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n            gl.uniform1i(textureLocation, 0);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 1 * 6);\r\n        });\r\n    }\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        0, 0,\r\n        1, 0,\r\n        0, zDepth,\r\n        0, zDepth,\r\n        1, 0,\r\n        1, zDepth,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\nfunction setGeometry(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        -0.5, 0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, 0.5, 0.5,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/05_3d_textures_mips_tri_linear.ts?");

/***/ }),

/***/ "./src/8_Textures/06_3d_textures_good_npot.ts":
/*!****************************************************!*\
  !*** ./src/8_Textures/06_3d_textures_good_npot.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_myMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/myMath */ \"./src/resources/myMath.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture,v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLcoation = gl.getUniformLocation(program, 'u_texture');\r\n    let positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBUffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n    setTexcoord(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/keyboard.jpg';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        if (_resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPowerOf2(image.width) && _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPowerOf2(image.height)) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n    });\r\n    let fieldOfViewRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(60);\r\n    let modelXRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(20);\r\n    let mdoelYRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(0);\r\n    let then = 0;\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(now) {\r\n        now *= 0.001;\r\n        let deltaTime = now - then;\r\n        then = now;\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        modelXRotationRadians += 1.2 * deltaTime;\r\n        mdoelYRotationRadians += -0.7 * deltaTime;\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.height;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, 1, 2000);\r\n        let cameraPosition = [0, 0, 200];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].xRotate(viewProjectionMatrix, modelXRotationRadians);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].yRotate(matrix, mdoelYRotationRadians);\r\n        gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n        gl.uniform1i(textureLcoation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 16 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setGeometry(gl) {\r\n    let positions = new Float32Array([\r\n        // left column front\r\n        0, 0, 0,\r\n        0, 150, 0,\r\n        30, 0, 0,\r\n        0, 150, 0,\r\n        30, 150, 0,\r\n        30, 0, 0,\r\n        // top rung front\r\n        30, 0, 0,\r\n        30, 30, 0,\r\n        100, 0, 0,\r\n        30, 30, 0,\r\n        100, 30, 0,\r\n        100, 0, 0,\r\n        // middle rung front\r\n        30, 60, 0,\r\n        30, 90, 0,\r\n        67, 60, 0,\r\n        30, 90, 0,\r\n        67, 90, 0,\r\n        67, 60, 0,\r\n        // left column back\r\n        0, 0, 30,\r\n        30, 0, 30,\r\n        0, 150, 30,\r\n        0, 150, 30,\r\n        30, 0, 30,\r\n        30, 150, 30,\r\n        // top rung back\r\n        30, 0, 30,\r\n        100, 0, 30,\r\n        30, 30, 30,\r\n        30, 30, 30,\r\n        100, 0, 30,\r\n        100, 30, 30,\r\n        // middle rung back\r\n        30, 60, 30,\r\n        67, 60, 30,\r\n        30, 90, 30,\r\n        30, 90, 30,\r\n        67, 60, 30,\r\n        67, 90, 30,\r\n        // top\r\n        0, 0, 0,\r\n        100, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 0,\r\n        100, 0, 30,\r\n        0, 0, 30,\r\n        // top rung right\r\n        100, 0, 0,\r\n        100, 30, 0,\r\n        100, 30, 30,\r\n        100, 0, 0,\r\n        100, 30, 30,\r\n        100, 0, 30,\r\n        // under top rung\r\n        30, 30, 0,\r\n        30, 30, 30,\r\n        100, 30, 30,\r\n        30, 30, 0,\r\n        100, 30, 30,\r\n        100, 30, 0,\r\n        // between top rung and middle\r\n        30, 30, 0,\r\n        30, 60, 30,\r\n        30, 30, 30,\r\n        30, 30, 0,\r\n        30, 60, 0,\r\n        30, 60, 30,\r\n        // top of middle rung\r\n        30, 60, 0,\r\n        67, 60, 30,\r\n        30, 60, 30,\r\n        30, 60, 0,\r\n        67, 60, 0,\r\n        67, 60, 30,\r\n        // right of middle rung\r\n        67, 60, 0,\r\n        67, 90, 30,\r\n        67, 60, 30,\r\n        67, 60, 0,\r\n        67, 90, 0,\r\n        67, 90, 30,\r\n        // bottom of middle rung.\r\n        30, 90, 0,\r\n        30, 90, 30,\r\n        67, 90, 30,\r\n        30, 90, 0,\r\n        67, 90, 30,\r\n        67, 90, 0,\r\n        // right of bottom\r\n        30, 90, 0,\r\n        30, 150, 30,\r\n        30, 90, 30,\r\n        30, 90, 0,\r\n        30, 150, 0,\r\n        30, 150, 30,\r\n        // bottom\r\n        0, 150, 0,\r\n        0, 150, 30,\r\n        30, 150, 30,\r\n        0, 150, 0,\r\n        30, 150, 30,\r\n        30, 150, 0,\r\n        // left side\r\n        0, 0, 0,\r\n        0, 0, 30,\r\n        0, 150, 30,\r\n        0, 0, 0,\r\n        0, 150, 30,\r\n        0, 150, 0\r\n    ]);\r\n    let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity();\r\n    matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(matrix, -50, -75, -15);\r\n    for (let ii = 0; ii < positions.length; ii += 3) {\r\n        let vector = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].transformVector(matrix, [positions[ii], positions[ii + 1], positions[ii + 2], 1]);\r\n        positions[ii] = vector[0];\r\n        positions[ii + 1] = vector[1];\r\n        positions[ii + 2] = vector[2];\r\n    }\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        // left column front\r\n        0.22, 0.19,\r\n        0.22, 0.79,\r\n        0.34, 0.19,\r\n        0.22, 0.79,\r\n        0.34, 0.79,\r\n        0.34, 0.19,\r\n        // top rung front\r\n        0.34, 0.19,\r\n        0.34, 0.31,\r\n        0.62, 0.19,\r\n        0.34, 0.31,\r\n        0.62, 0.31,\r\n        0.62, 0.19,\r\n        // middle rung front\r\n        0.34, 0.43,\r\n        0.34, 0.55,\r\n        0.49, 0.43,\r\n        0.34, 0.55,\r\n        0.49, 0.55,\r\n        0.49, 0.43,\r\n        // left column back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // top rung back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // middle rung back\r\n        0, 0,\r\n        1, 0,\r\n        0, 1,\r\n        0, 1,\r\n        1, 0,\r\n        1, 1,\r\n        // top\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // top rung right\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        // under top rung\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // between top rung and middle\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // top of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // right of middle rung\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom of middle rung.\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // right of bottom\r\n        0, 0,\r\n        1, 1,\r\n        0, 1,\r\n        0, 0,\r\n        1, 0,\r\n        1, 1,\r\n        // bottom\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n        // left side\r\n        0, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        1, 1,\r\n        1, 0,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/06_3d_textures_good_npot.ts?");

/***/ }),

/***/ "./src/8_Textures/07_3d_textures_texture_atlas.ts":
/*!********************************************************!*\
  !*** ./src/8_Textures/07_3d_textures_texture_atlas.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_myMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/myMath */ \"./src/resources/myMath.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture,v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    setGeometry(gl);\r\n    const texcoordBUffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n    setTexcoord(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n    let image = new Image();\r\n    image.src = './resources/images/noodles.jpg';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        if (_resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPowerOf2(image.width) && _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPowerOf2(image.height)) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n    });\r\n    let fieldOfViewRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(60);\r\n    let modelXRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(0);\r\n    let modelYRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(0);\r\n    let then = 0;\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(time) {\r\n        time *= 0.001;\r\n        let deltaTime = time - then;\r\n        then = time;\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        modelXRotationRadians += -0.7 * deltaTime;\r\n        modelYRotationRadians += -0.4 * deltaTime;\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBUffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldOfViewRadians, aspect, 1, 2000);\r\n        let cameraPosition = [0, 0, 2];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraPosition, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].xRotate(viewProjectionMatrix, modelXRotationRadians);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].yRotate(matrix, modelYRotationRadians);\r\n        gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n        gl.uniform1i(textureLocation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setGeometry(gl) {\r\n    let positions = new Float32Array([\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, -0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, 0.5, 0.5,\r\n    ]);\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        // select the top left image\r\n        0, 0,\r\n        0, 0.5,\r\n        0.25, 0,\r\n        0, 0.5,\r\n        0.25, 0.5,\r\n        0.25, 0,\r\n        // select the top middle image\r\n        0.25, 0,\r\n        0.5, 0,\r\n        0.25, 0.5,\r\n        0.25, 0.5,\r\n        0.5, 0,\r\n        0.5, 0.5,\r\n        // select to top right image\r\n        0.5, 0,\r\n        0.5, 0.5,\r\n        0.75, 0,\r\n        0.5, 0.5,\r\n        0.75, 0.5,\r\n        0.75, 0,\r\n        // select the bottom left image\r\n        0, 0.5,\r\n        0.25, 0.5,\r\n        0, 1,\r\n        0, 1,\r\n        0.25, 0.5,\r\n        0.25, 1,\r\n        // select the bottom middle image\r\n        0.25, 0.5,\r\n        0.25, 1,\r\n        0.5, 0.5,\r\n        0.25, 1,\r\n        0.5, 1,\r\n        0.5, 0.5,\r\n        // select the bottom right image\r\n        0.5, 0.5,\r\n        0.75, 0.5,\r\n        0.5, 1,\r\n        0.5, 1,\r\n        0.75, 0.5,\r\n        0.75, 1,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/07_3d_textures_texture_atlas.ts?");

/***/ }),

/***/ "./src/8_Textures/08_data_texture_3x2.ts":
/*!***********************************************!*\
  !*** ./src/8_Textures/08_data_texture_3x2.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_m4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/m4 */ \"./src/resources/m4.ts\");\n/* harmony import */ var _resources_myMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/myMath */ \"./src/resources/myMath.ts\");\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\n\r\n\r\nconst vertexShader3d = `\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(){\r\n    gl_Position = u_matrix * a_position;\r\n    v_texcoord = a_texcoord;\r\n}`;\r\nconst fragmentShader3d = `\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(u_texture, v_texcoord);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.getElementById('canvas');\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createProgramFromStrings(gl, [vertexShader3d, fragmentShader3d]);\r\n    const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    const texcoordLocation = gl.getAttribLocation(program, 'a_texcoord');\r\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\r\n    const textureLocation = gl.getUniformLocation(program, 'u_texture');\r\n    let posiitonBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, posiitonBuffer);\r\n    setGeometry(gl);\r\n    let texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    setTexcoord(gl);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, 3, 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, new Uint8Array([\r\n        128, 64, 128,\r\n        0, 192, 0\r\n    ]));\r\n    const alignment = 1;\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, 3, 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, new Uint8Array([\r\n        128, 64, 128,\r\n        0, 192, 0\r\n    ]));\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    let fieldofViewRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(60);\r\n    let modelXRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(0);\r\n    let modelYRotationRadians = _resources_myMath__WEBPACK_IMPORTED_MODULE_1__[\"default\"].degToRad(0);\r\n    let then = 0;\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(time) {\r\n        time *= 0.001;\r\n        let deltaTime = time - then;\r\n        then = time;\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        modelXRotationRadians += -0.7 * deltaTime;\r\n        modelYRotationRadians += -0.4 * deltaTime;\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.enableVertexAttribArray(positionLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, posiitonBuffer);\r\n        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(texcoordLocation);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n        gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(fieldofViewRadians, aspect, 1, 2000);\r\n        let cameraLocation = [0, 0, 2];\r\n        let up = [0, 1, 0];\r\n        let target = [0, 0, 0];\r\n        let cameraMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(cameraLocation, target, up);\r\n        let viewMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse(cameraMatrix);\r\n        let viewProjectionMatrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(projectionMatrix, viewMatrix);\r\n        let matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].xRotate(viewProjectionMatrix, modelXRotationRadians);\r\n        matrix = _resources_m4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].yRotate(matrix, modelYRotationRadians);\r\n        gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n        gl.uniform1i(textureLocation, 0);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6 * 6);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n}\r\nfunction setGeometry(gl) {\r\n    let positions = new Float32Array([\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, -0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, 0.5, 0.5,\r\n    ]);\r\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\r\n}\r\nfunction setTexcoord(gl) {\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n        1, 0,\r\n        0, 0,\r\n        0, 1,\r\n        1, 0,\r\n        1, 0,\r\n        0, 1,\r\n        1, 1,\r\n    ]), gl.STATIC_DRAW);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/8_Textures/08_data_texture_3x2.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"webgl_01_fundamental\": () => (/* reexport safe */ _1_Fundamentals_01_fundamentals__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"webgl_02_2d_rectangle\": () => (/* reexport safe */ _1_Fundamentals_02_2d_rectangle__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"webgl_03_2d_rectangle_top_left\": () => (/* reexport safe */ _1_Fundamentals_03_2d_rectangle_top_left__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"webgl_04_2d_rectangles\": () => (/* reexport safe */ _1_Fundamentals_04_2d_rectangles__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"webgl_08_01_3d_textures\": () => (/* reexport safe */ _8_Textures_01_3d_textures__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"webgl_08_02_3d_textures_texture_coords_mapped\": () => (/* reexport safe */ _8_Textures_02_3d_textures_texture_coords_mapped__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   \"webgl_08_03_3d_textures_repear_clamp\": () => (/* reexport safe */ _8_Textures_03_3d_textures_repear_clamp__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   \"webgl_08_04_3d_textures_mips\": () => (/* reexport safe */ _8_Textures_04_3d_textures_mips__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   \"webgl_08_05_3d_textures_mips_tri_linear\": () => (/* reexport safe */ _8_Textures_05_3d_textures_mips_tri_linear__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   \"webgl_08_06_3d_textures_good_npot\": () => (/* reexport safe */ _8_Textures_06_3d_textures_good_npot__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   \"webgl_08_07_3d_textures_texture_atlas\": () => (/* reexport safe */ _8_Textures_07_3d_textures_texture_atlas__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   \"webgl_08_08_data_texture_3x2\": () => (/* reexport safe */ _8_Textures_08_data_texture_3x2__WEBPACK_IMPORTED_MODULE_11__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _1_Fundamentals_01_fundamentals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./1_Fundamentals/01_fundamentals */ \"./src/1_Fundamentals/01_fundamentals.ts\");\n/* harmony import */ var _1_Fundamentals_02_2d_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./1_Fundamentals/02_2d_rectangle */ \"./src/1_Fundamentals/02_2d_rectangle.ts\");\n/* harmony import */ var _1_Fundamentals_03_2d_rectangle_top_left__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1_Fundamentals/03_2d_rectangle_top_left */ \"./src/1_Fundamentals/03_2d_rectangle_top_left.ts\");\n/* harmony import */ var _1_Fundamentals_04_2d_rectangles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./1_Fundamentals/04_2d_rectangles */ \"./src/1_Fundamentals/04_2d_rectangles.ts\");\n/* harmony import */ var _8_Textures_01_3d_textures__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./8_Textures/01_3d_textures */ \"./src/8_Textures/01_3d_textures.ts\");\n/* harmony import */ var _8_Textures_02_3d_textures_texture_coords_mapped__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./8_Textures/02_3d_textures_texture_coords_mapped */ \"./src/8_Textures/02_3d_textures_texture_coords_mapped.ts\");\n/* harmony import */ var _8_Textures_03_3d_textures_repear_clamp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./8_Textures/03_3d_textures_repear_clamp */ \"./src/8_Textures/03_3d_textures_repear_clamp.ts\");\n/* harmony import */ var _8_Textures_04_3d_textures_mips__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./8_Textures/04-3d-textures-mips */ \"./src/8_Textures/04-3d-textures-mips.ts\");\n/* harmony import */ var _8_Textures_05_3d_textures_mips_tri_linear__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./8_Textures/05_3d_textures_mips_tri_linear */ \"./src/8_Textures/05_3d_textures_mips_tri_linear.ts\");\n/* harmony import */ var _8_Textures_06_3d_textures_good_npot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./8_Textures/06_3d_textures_good_npot */ \"./src/8_Textures/06_3d_textures_good_npot.ts\");\n/* harmony import */ var _8_Textures_07_3d_textures_texture_atlas__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./8_Textures/07_3d_textures_texture_atlas */ \"./src/8_Textures/07_3d_textures_texture_atlas.ts\");\n/* harmony import */ var _8_Textures_08_data_texture_3x2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./8_Textures/08_data_texture_3x2 */ \"./src/8_Textures/08_data_texture_3x2.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/index.ts?");

/***/ }),

/***/ "./src/resources/m4.ts":
/*!*****************************!*\
  !*** ./src/resources/m4.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n   * Makes an identity matrix.\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction identity(dst) {\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = 1;\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 1;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = 1;\r\n    dst[11] = 0;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = 0;\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n   * Mutliply by translation matrix.\r\n   * @param {Matrix4} m matrix to multiply\r\n   * @param {number} tx x translation.\r\n   * @param {number} ty y translation.\r\n   * @param {number} tz z translation.\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction translate(m, tx, ty, tz, dst) {\r\n    // This is the optimized version of\r\n    // return multiply(m, translation(tx, ty, tz), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0];\r\n    var m01 = m[1];\r\n    var m02 = m[2];\r\n    var m03 = m[3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var m30 = m[3 * 4 + 0];\r\n    var m31 = m[3 * 4 + 1];\r\n    var m32 = m[3 * 4 + 2];\r\n    var m33 = m[3 * 4 + 3];\r\n    if (m !== dst) {\r\n        dst[0] = m00;\r\n        dst[1] = m01;\r\n        dst[2] = m02;\r\n        dst[3] = m03;\r\n        dst[4] = m10;\r\n        dst[5] = m11;\r\n        dst[6] = m12;\r\n        dst[7] = m13;\r\n        dst[8] = m20;\r\n        dst[9] = m21;\r\n        dst[10] = m22;\r\n        dst[11] = m23;\r\n    }\r\n    dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;\r\n    dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;\r\n    dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;\r\n    dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;\r\n    return dst;\r\n}\r\n/**\r\n * Takes a  matrix and a vector with 4 entries, transforms that vector by\r\n * the matrix, and returns the result as a vector with 4 entries.\r\n * @param {Matrix4} m The matrix.\r\n * @param {Vector4} v The point in homogenous coordinates.\r\n * @param {Vector4} dst optional vector4 to store result\r\n * @return {Vector4} dst or new Vector4 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction transformVector(m, v, dst) {\r\n    dst = dst || new Float32Array(4);\r\n    for (var i = 0; i < 4; ++i) {\r\n        dst[i] = 0.0;\r\n        for (var j = 0; j < 4; ++j) {\r\n            dst[i] += v[j] * m[j * 4 + i];\r\n        }\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n   * Computes a 4-by-4 perspective transformation matrix given the angular height\r\n   * of the frustum, the aspect ratio, and the near and far clipping planes.  The\r\n   * arguments define a frustum extending in the negative z direction.  The given\r\n   * angle is the vertical angle of the frustum, and the horizontal angle is\r\n   * determined to produce the given aspect ratio.  The arguments near and far are\r\n   * the distances to the near and far clipping planes.  Note that near and far\r\n   * are not z coordinates, but rather they are distances along the negative\r\n   * z-axis.  The matrix generated sends the viewing frustum to the unit box.\r\n   * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n   * from -1 to 1 in the z dimension.\r\n   * @param {number} fieldOfViewInRadians field of view in y axis.\r\n   * @param {number} aspect aspect of viewport (width / height)\r\n   * @param {number} near near Z clipping plane\r\n   * @param {number} far far Z clipping plane\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction perspective(fieldOfViewInRadians, aspect, near, far, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\r\n    var rangeInv = 1.0 / (near - far);\r\n    dst[0] = f / aspect;\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = f;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = (near + far) * rangeInv;\r\n    dst[11] = -1;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = near * far * rangeInv * 2;\r\n    dst[15] = 0;\r\n    return dst;\r\n}\r\n/**\r\n   * normalizes a vector.\r\n   * @param {Vector3} v vector to normalzie\r\n   * @param {Vector3} dst optional vector3 to store result\r\n   * @return {Vector3} dst or new Vector3 if not provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction normalize(v, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n    // make sure we don't divide by 0.\r\n    if (length > 0.00001) {\r\n        dst[0] = v[0] / length;\r\n        dst[1] = v[1] / length;\r\n        dst[2] = v[2] / length;\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * subtracts 2 vectors3s\r\n * @param {Vector3} a a\r\n * @param {Vector3} b b\r\n * @param {Vector3} dst optional vector3 to store result\r\n * @return {Vector3} dst or new Vector3 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction subtractVectors(a, b, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    dst[0] = a[0] - b[0];\r\n    dst[1] = a[1] - b[1];\r\n    dst[2] = a[2] - b[2];\r\n    return dst;\r\n}\r\n/**\r\n   * Computes the cross product of 2 vectors3s\r\n   * @param {Vector3} a a\r\n   * @param {Vector3} b b\r\n   * @param {Vector3} dst optional vector3 to store result\r\n   * @return {Vector3} dst or new Vector3 if not provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction cross(a, b, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    dst[0] = a[1] * b[2] - a[2] * b[1];\r\n    dst[1] = a[2] * b[0] - a[0] * b[2];\r\n    dst[2] = a[0] * b[1] - a[1] * b[0];\r\n    return dst;\r\n}\r\n/**\r\n   * Creates a lookAt matrix.\r\n   * This is a world matrix for a camera. In other words it will transform\r\n   * from the origin to a place and orientation in the world. For a view\r\n   * matrix take the inverse of this.\r\n   * @param {Vector3} cameraPosition position of the camera\r\n   * @param {Vector3} target position of the target\r\n   * @param {Vector3} up direction\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction lookAt(cameraPosition, target, up, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var zAxis = normalize(subtractVectors(cameraPosition, target));\r\n    var xAxis = normalize(cross(up, zAxis));\r\n    var yAxis = normalize(cross(zAxis, xAxis));\r\n    dst[0] = xAxis[0];\r\n    dst[1] = xAxis[1];\r\n    dst[2] = xAxis[2];\r\n    dst[3] = 0;\r\n    dst[4] = yAxis[0];\r\n    dst[5] = yAxis[1];\r\n    dst[6] = yAxis[2];\r\n    dst[7] = 0;\r\n    dst[8] = zAxis[0];\r\n    dst[9] = zAxis[1];\r\n    dst[10] = zAxis[2];\r\n    dst[11] = 0;\r\n    dst[12] = cameraPosition[0];\r\n    dst[13] = cameraPosition[1];\r\n    dst[14] = cameraPosition[2];\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n   * Computes the inverse of a matrix.\r\n   * @param {Matrix4} m matrix to compute inverse of\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction inverse(m, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var m30 = m[3 * 4 + 0];\r\n    var m31 = m[3 * 4 + 1];\r\n    var m32 = m[3 * 4 + 2];\r\n    var m33 = m[3 * 4 + 3];\r\n    var tmp_0 = m22 * m33;\r\n    var tmp_1 = m32 * m23;\r\n    var tmp_2 = m12 * m33;\r\n    var tmp_3 = m32 * m13;\r\n    var tmp_4 = m12 * m23;\r\n    var tmp_5 = m22 * m13;\r\n    var tmp_6 = m02 * m33;\r\n    var tmp_7 = m32 * m03;\r\n    var tmp_8 = m02 * m23;\r\n    var tmp_9 = m22 * m03;\r\n    var tmp_10 = m02 * m13;\r\n    var tmp_11 = m12 * m03;\r\n    var tmp_12 = m20 * m31;\r\n    var tmp_13 = m30 * m21;\r\n    var tmp_14 = m10 * m31;\r\n    var tmp_15 = m30 * m11;\r\n    var tmp_16 = m10 * m21;\r\n    var tmp_17 = m20 * m11;\r\n    var tmp_18 = m00 * m31;\r\n    var tmp_19 = m30 * m01;\r\n    var tmp_20 = m00 * m21;\r\n    var tmp_21 = m20 * m01;\r\n    var tmp_22 = m00 * m11;\r\n    var tmp_23 = m10 * m01;\r\n    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\r\n        (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\r\n        (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\r\n        (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\r\n        (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    dst[0] = d * t0;\r\n    dst[1] = d * t1;\r\n    dst[2] = d * t2;\r\n    dst[3] = d * t3;\r\n    dst[4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\r\n        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\r\n    dst[5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\r\n        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\r\n    dst[6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\r\n        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\r\n    dst[7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\r\n        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\r\n    dst[8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\r\n        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\r\n    dst[9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\r\n        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\r\n    dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\r\n        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\r\n    dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\r\n        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\r\n    dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\r\n        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\r\n    dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\r\n        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\r\n    dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\r\n        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\r\n    dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\r\n        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\r\n    return dst;\r\n}\r\n/**\r\n   * Takes two 4-by-4 matrices, a and b, and computes the product in the order\r\n   * that pre-composes b with a.  In other words, the matrix returned will\r\n   * transform by b first and then a.  Note this is subtly different from just\r\n   * multiplying the matrices together.  For given a and b, this function returns\r\n   * the same object in both row-major and column-major mode.\r\n   * @param {Matrix4} a A matrix.\r\n   * @param {Matrix4} b A matrix.\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   */\r\nfunction multiply(a, b, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var b00 = b[0 * 4 + 0];\r\n    var b01 = b[0 * 4 + 1];\r\n    var b02 = b[0 * 4 + 2];\r\n    var b03 = b[0 * 4 + 3];\r\n    var b10 = b[1 * 4 + 0];\r\n    var b11 = b[1 * 4 + 1];\r\n    var b12 = b[1 * 4 + 2];\r\n    var b13 = b[1 * 4 + 3];\r\n    var b20 = b[2 * 4 + 0];\r\n    var b21 = b[2 * 4 + 1];\r\n    var b22 = b[2 * 4 + 2];\r\n    var b23 = b[2 * 4 + 3];\r\n    var b30 = b[3 * 4 + 0];\r\n    var b31 = b[3 * 4 + 1];\r\n    var b32 = b[3 * 4 + 2];\r\n    var b33 = b[3 * 4 + 3];\r\n    var a00 = a[0 * 4 + 0];\r\n    var a01 = a[0 * 4 + 1];\r\n    var a02 = a[0 * 4 + 2];\r\n    var a03 = a[0 * 4 + 3];\r\n    var a10 = a[1 * 4 + 0];\r\n    var a11 = a[1 * 4 + 1];\r\n    var a12 = a[1 * 4 + 2];\r\n    var a13 = a[1 * 4 + 3];\r\n    var a20 = a[2 * 4 + 0];\r\n    var a21 = a[2 * 4 + 1];\r\n    var a22 = a[2 * 4 + 2];\r\n    var a23 = a[2 * 4 + 3];\r\n    var a30 = a[3 * 4 + 0];\r\n    var a31 = a[3 * 4 + 1];\r\n    var a32 = a[3 * 4 + 2];\r\n    var a33 = a[3 * 4 + 3];\r\n    dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\r\n    dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\r\n    dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\r\n    dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\r\n    dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\r\n    dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\r\n    dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\r\n    dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\r\n    dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\r\n    dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\r\n    dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\r\n    dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\r\n    dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\r\n    dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\r\n    dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\r\n    dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\r\n    return dst;\r\n}\r\n/**\r\n   * Multiply by an x rotation matrix\r\n   * @param {Matrix4} m matrix to multiply\r\n   * @param {number} angleInRadians amount to rotate\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction xRotate(m, angleInRadians, dst) {\r\n    // this is the optimized version of\r\n    // return multiply(m, xRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m10 = m[4];\r\n    var m11 = m[5];\r\n    var m12 = m[6];\r\n    var m13 = m[7];\r\n    var m20 = m[8];\r\n    var m21 = m[9];\r\n    var m22 = m[10];\r\n    var m23 = m[11];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[4] = c * m10 + s * m20;\r\n    dst[5] = c * m11 + s * m21;\r\n    dst[6] = c * m12 + s * m22;\r\n    dst[7] = c * m13 + s * m23;\r\n    dst[8] = c * m20 - s * m10;\r\n    dst[9] = c * m21 - s * m11;\r\n    dst[10] = c * m22 - s * m12;\r\n    dst[11] = c * m23 - s * m13;\r\n    if (m !== dst) {\r\n        dst[0] = m[0];\r\n        dst[1] = m[1];\r\n        dst[2] = m[2];\r\n        dst[3] = m[3];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * Makes an y rotation matrix\r\n * @param {number} angleInRadians amount to rotate\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction yRotation(angleInRadians, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c;\r\n    dst[1] = 0;\r\n    dst[2] = -s;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 1;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = s;\r\n    dst[9] = 0;\r\n    dst[10] = c;\r\n    dst[11] = 0;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = 0;\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n   * Multiply by an y rotation matrix\r\n   * @param {Matrix4} m matrix to multiply\r\n   * @param {number} angleInRadians amount to rotate\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction yRotate(m, angleInRadians, dst) {\r\n    // this is the optimized verison of\r\n    // return multiply(m, yRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c * m00 - s * m20;\r\n    dst[1] = c * m01 - s * m21;\r\n    dst[2] = c * m02 - s * m22;\r\n    dst[3] = c * m03 - s * m23;\r\n    dst[8] = c * m20 + s * m00;\r\n    dst[9] = c * m21 + s * m01;\r\n    dst[10] = c * m22 + s * m02;\r\n    dst[11] = c * m23 + s * m03;\r\n    if (m !== dst) {\r\n        dst[4] = m[4];\r\n        dst[5] = m[5];\r\n        dst[6] = m[6];\r\n        dst[7] = m[7];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n   * Multiply by an z rotation matrix\r\n   * @param {Matrix4} m matrix to multiply\r\n   * @param {number} angleInRadians amount to rotate\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction zRotate(m, angleInRadians, dst) {\r\n    // This is the optimized verison of\r\n    // return multiply(m, zRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c * m00 + s * m10;\r\n    dst[1] = c * m01 + s * m11;\r\n    dst[2] = c * m02 + s * m12;\r\n    dst[3] = c * m03 + s * m13;\r\n    dst[4] = c * m10 - s * m00;\r\n    dst[5] = c * m11 - s * m01;\r\n    dst[6] = c * m12 - s * m02;\r\n    dst[7] = c * m13 - s * m03;\r\n    if (m !== dst) {\r\n        dst[8] = m[8];\r\n        dst[9] = m[9];\r\n        dst[10] = m[10];\r\n        dst[11] = m[11];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n   * Computes a 4-by-4 orthographic projection matrix given the coordinates of the\r\n   * planes defining the axis-aligned, box-shaped viewing volume.  The matrix\r\n   * generated sends that box to the unit box.  Note that although left and right\r\n   * are x coordinates and bottom and top are y coordinates, near and far\r\n   * are not z coordinates, but rather they are distances along the negative\r\n   * z-axis.  We assume a unit box extending from -1 to 1 in the x and y\r\n   * dimensions and from -1 to 1 in the z dimension.\r\n   * @param {number} left The x coordinate of the left plane of the box.\r\n   * @param {number} right The x coordinate of the right plane of the box.\r\n   * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n   * @param {number} top The y coordinate of the right plane of the box.\r\n   * @param {number} near The negative z coordinate of the near plane of the box.\r\n   * @param {number} far The negative z coordinate of the far plane of the box.\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction orthographic(left, right, bottom, top, near, far, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = 2 / (right - left);\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 2 / (top - bottom);\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = 2 / (near - far);\r\n    dst[11] = 0;\r\n    dst[12] = (left + right) / (left - right);\r\n    dst[13] = (bottom + top) / (bottom - top);\r\n    dst[14] = (near + far) / (near - far);\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n   * Multiply by a scaling matrix\r\n   * @param {Matrix4} m matrix to multiply\r\n   * @param {number} sx x scale.\r\n   * @param {number} sy y scale.\r\n   * @param {number} sz z scale.\r\n   * @param {Matrix4} [dst] optional matrix to store result\r\n   * @return {Matrix4} dst or a new matrix if none provided\r\n   * @memberOf module:webgl-3d-math\r\n   */\r\nfunction scale(m, sx, sy, sz, dst) {\r\n    // This is the optimized verison of\r\n    // return multiply(m, scaling(sx, sy, sz), dst);\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = sx * m[0 * 4 + 0];\r\n    dst[1] = sx * m[0 * 4 + 1];\r\n    dst[2] = sx * m[0 * 4 + 2];\r\n    dst[3] = sx * m[0 * 4 + 3];\r\n    dst[4] = sy * m[1 * 4 + 0];\r\n    dst[5] = sy * m[1 * 4 + 1];\r\n    dst[6] = sy * m[1 * 4 + 2];\r\n    dst[7] = sy * m[1 * 4 + 3];\r\n    dst[8] = sz * m[2 * 4 + 0];\r\n    dst[9] = sz * m[2 * 4 + 1];\r\n    dst[10] = sz * m[2 * 4 + 2];\r\n    dst[11] = sz * m[2 * 4 + 3];\r\n    if (m !== dst) {\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    identity,\r\n    translate,\r\n    transformVector,\r\n    perspective,\r\n    lookAt,\r\n    inverse,\r\n    multiply,\r\n    xRotate,\r\n    yRotate,\r\n    zRotate,\r\n    yRotation,\r\n    orthographic,\r\n    scale,\r\n});\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/m4.ts?");

/***/ }),

/***/ "./src/resources/myMath.ts":
/*!*********************************!*\
  !*** ./src/resources/myMath.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction isPowerOf2(value) {\r\n    return (value & (value - 1)) === 0;\r\n}\r\nfunction degToRad(d) {\r\n    return d * Math.PI / 180;\r\n}\r\nfunction radToDeg(r) {\r\n    return r * 180 / Math.PI;\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    isPowerOf2,\r\n    degToRad,\r\n    radToDeg,\r\n});\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/myMath.ts?");

/***/ }),

/***/ "./src/resources/webgl-utils.ts":
/*!**************************************!*\
  !*** ./src/resources/webgl-utils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// export default class webglUtils {\r\n/**\r\n   * Wrapped logging function.\r\n   * @param {string} msg The message to log.\r\n   */\r\nfunction error(msg) {\r\n    // if (this.topWindow.console) {\r\n    //     if (topWindow.console.error) {\r\n    //         topWindow.console.error(msg);\r\n    //     } else if (topWindow.console.log) {\r\n    //         topWindow.console.log(msg);\r\n    //     }\r\n    // }\r\n}\r\n/**\r\n* Resize a canvas to match the size its displayed.\r\n* @param {HTMLCanvasElement} canvas The canvas to resize.\r\n* @param {number} [multiplier] amount to multiply by.\r\n*    Pass in window.devicePixelRatio for native pixels.\r\n* @return {boolean} true if the canvas was resized.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\r\n    multiplier = multiplier || 1;\r\n    var width = canvas.clientWidth * multiplier | 0;\r\n    var height = canvas.clientHeight * multiplier | 0;\r\n    if (canvas.width !== width || canvas.height !== height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nconst defaultShaderType = [\r\n    \"VERTEX_SHADER\",\r\n    \"FRAGMENT_SHADER\",\r\n];\r\n/**\r\n* Creates a program from 2 script tags.\r\n* @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n* @param {string[]} shaderStrings Array of ids of the script tags for the shaders. The first is assumed to be the\r\nvertex shader, the second the fragment shader.\r\n* @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n* @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n* @param {} opt_errorCallback callback for errors. By default it just prints an error to the console\r\non error. If you want something else pass an callback. It's passed an error message.\r\n* @return {WebGLProgram} The created program.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction createProgramFromStrings(gl, shaderStrings, opt_attribs, opt_locations, opt_errorCallback) {\r\n    var shaders = [];\r\n    for (var ii = 0; ii < shaderStrings.length; ++ii) {\r\n        shaders.push(createShaderFromString(gl, shaderStrings[ii], gl[defaultShaderType[ii]], opt_errorCallback));\r\n    }\r\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\r\n}\r\n/**\r\n* Loads a shader from a script tag.\r\n* @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n* @param {string} shaderString The id of the script tag.\r\n* @param {number} opt_shaderType The type of shader. If not passed in it will\r\nbe derived from the type of the script tag.\r\n* @param {} opt_errorCallback callback for errors.\r\n* @return {WebGLShader} The created shader.\r\n*/\r\nfunction createShaderFromString(gl, shaderString, opt_shaderType, opt_errorCallback) {\r\n    var shaderSource = \"\";\r\n    var shaderType;\r\n    // var shaderScript = document.getElementById(scriptId);\r\n    // if (!shaderScript) {\r\n    //     throw (\"*** Error: unknown script element\" + scriptId);\r\n    // }\r\n    shaderSource = shaderString;\r\n    // if (!opt_shaderType) {\r\n    //     if (shaderScript.type === \"x-shader/x-vertex\") {\r\n    //         shaderType = gl.VERTEX_SHADER;\r\n    //     } else if (shaderScript.type === \"x-shader/x-fragment\") {\r\n    //         shaderType = gl.FRAGMENT_SHADER;\r\n    //     } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\r\n    //         throw (\"*** Error: unknown shader type\");\r\n    //     }\r\n    // }\r\n    return loadShader(gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType, opt_errorCallback);\r\n}\r\n/**\r\n   * Loads a shader.\r\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n   * @param {string} shaderSource The shader source.\r\n   * @param {number} shaderType The type of shader.\r\n   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n   * @return {WebGLShader} The created shader.\r\n   */\r\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\r\n    var errFn = opt_errorCallback || error;\r\n    // Create the shader object\r\n    var shader = gl.createShader(shaderType);\r\n    // Load the shader source\r\n    gl.shaderSource(shader, shaderSource);\r\n    // Compile the shader\r\n    gl.compileShader(shader);\r\n    // Check the compile status\r\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!compiled) {\r\n        // Something went wrong during compilation; get the error\r\n        var lastError = gl.getShaderInfoLog(shader);\r\n        console.error(\"*** Error compiling shader '\" + shader + \"':\" + lastError);\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    return shader;\r\n}\r\n/**\r\n* Creates a program, attaches shaders, binds attrib locations, links the\r\n* program and calls useProgram.\r\n* @param {WebGLShader[]} shaders The shaders to attach\r\n* @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n* @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n* @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n*        on error. If you want something else pass an callback. It's passed an error message.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\r\n    var errFn = opt_errorCallback || error;\r\n    var program = gl.createProgram();\r\n    shaders.forEach(function (shader) {\r\n        gl.attachShader(program, shader);\r\n    });\r\n    if (opt_attribs) {\r\n        opt_attribs.forEach(function (attrib, ndx) {\r\n            gl.bindAttribLocation(program, opt_locations ? opt_locations[ndx] : ndx, attrib);\r\n        });\r\n    }\r\n    gl.linkProgram(program);\r\n    // Check the link status\r\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!linked) {\r\n        // something went wrong with the link\r\n        var lastError = gl.getProgramInfoLog(program);\r\n        errFn(\"Error in program linking:\" + lastError);\r\n        gl.deleteProgram(program);\r\n        return null;\r\n    }\r\n    return program;\r\n}\r\n// }\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    resizeCanvasToDisplaySize,\r\n    createProgram,\r\n    createProgramFromStrings\r\n});\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/webgl-utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;